/**
 * Exploit Detection Simulation
 *
 * Tests AFK farming viability, death-decision reset exploit,
 * PvP target sniping, bot farming ceiling, and energy waste checks.
 */
import {
  PASSIVE_CREDITS_PER_HOUR,
  PASSIVE_DATA_PER_HOUR,
  PASSIVE_MAX_HOURS,
  DEGRADATION_RATE_PER_HOUR,
  ALL_DECISIONS,
  DECISION_TRIGGER_CHANCES,
  DECISION_BALANCE,
  PVP_MAX_ATTACKS_RECEIVED,
  PVP_LOSER_DAMAGE_MIN_PCT,
  PVP_LOSER_DAMAGE_MAX_PCT,
  PVP_LOSER_SYSTEMS_MIN,
  PVP_LOSER_SYSTEMS_MAX,
  getRepairCreditCostForHealth,
  getDecisionResourceCap,
} from "@singularities/shared";
import { BOT_MAX_ATTACKS_PER_DAY } from "../services/arenaBots.js";
import {
  Rng,
  parseCliOptions,
  average,
  PlayerState,
  tickDegradation,
  tickCascade,
  simulateRepair,
  checkDeath,
  printGuardrails,
} from "./lib.js";

// -- Scenario 1: AFK Farming --
interface AfkResult {
  passiveCreditsPerDay: number;
  repairCostPerDay: number;
  netPerDay: number;
  sustainable: boolean;
}

function runAfkFarming(seed: number, days: number): AfkResult {
  const state = new PlayerState(10);
  state.credits = 1000;
  const startCredits = state.credits;
  let totalRepairCost = 0;

  for (let day = 0; day < days; day++) {
    // 24h passive income
    const passiveC = PASSIVE_CREDITS_PER_HOUR * Math.min(24, PASSIVE_MAX_HOURS);
    const passiveD = PASSIVE_DATA_PER_HOUR * Math.min(24, PASSIVE_MAX_HOURS);
    state.credits += passiveC;
    state.data += passiveD;

    // 24h degradation
    tickDegradation(state, 24);
    for (let t = 0; t < 48; t++) tickCascade(state);

    // 1 repair session per day (minimal maintenance)
    for (let i = 0; i < 6; i++) {
      if (state.systems[i] < 50) {
        state.energy = state.energyMax;
        const cost = simulateRepair(state, i);
        if (cost >= 0) totalRepairCost += cost;
      }
    }

    if (checkDeath(state)) break;
  }

  const netPerDay = (state.credits - startCredits - totalRepairCost) / days;
  return {
    passiveCreditsPerDay: PASSIVE_CREDITS_PER_HOUR * Math.min(24, PASSIVE_MAX_HOURS),
    repairCostPerDay: totalRepairCost / days,
    netPerDay,
    sustainable: netPerDay > 0,
  };
}

// -- Scenario 2: Decision Reset via Death --
interface DecisionResetResult {
  totalReseableValue: number;
}

function runDecisionReset(): DecisionResetResult {
  // Calculate total value of all decisions if re-seen
  let totalVal = 0;
  for (const dec of ALL_DECISIONS) {
    if (dec.levelRequirement > 10) continue;
    // Take the better of yes/no for resource grants
    for (const effects of [dec.yesEffects, dec.noEffects]) {
      let val = 0;
      for (const e of effects) {
        if (e.type !== "resource_grant") continue;
        if (e.target === "credits") val += e.value;
        else if (e.target === "data") val += e.value * 1.5;
        else if (e.target === "processingPower") val += e.value * 4;
        else if (e.target === "reputation") val += e.value * 0.8;
      }
      totalVal = Math.max(totalVal, val);
    }
  }
  return { totalReseableValue: totalVal };
}

// -- Scenario 3: PvP Target Sniping --
interface PvpSnipeResult {
  maxDailyDamage: number;
  isCapSufficient: boolean;
}

function runPvpSniping(seed: number): PvpSnipeResult {
  const rng = new Rng(seed);
  // Max damage from 3 attacks (PVP_MAX_ATTACKS_RECEIVED)
  let totalDmg = 0;
  for (let a = 0; a < PVP_MAX_ATTACKS_RECEIVED; a++) {
    const systemsHit = rng.int(PVP_LOSER_SYSTEMS_MIN, PVP_LOSER_SYSTEMS_MAX);
    for (let s = 0; s < systemsHit; s++) {
      totalDmg += rng.int(PVP_LOSER_DAMAGE_MIN_PCT, PVP_LOSER_DAMAGE_MAX_PCT);
    }
  }
  return {
    maxDailyDamage: totalDmg,
    isCapSufficient: totalDmg < 120, // Less than 20% of total HP pool (600)
  };
}

// -- Scenario 4: Bot Farming Ceiling --
interface BotFarmResult {
  maxDailyCredits: number;
  normalIncomeComparison: number; // Ratio vs hacking
}

function runBotFarming(seed: number): BotFarmResult {
  const rng = new Rng(seed);
  let totalCredits = 0;
  // Bot rewards are intentionally lower than human PvP rewards.
  for (let a = 0; a < BOT_MAX_ATTACKS_PER_DAY; a++) {
    const mult = 0.52 + rng.next() * 0.20;
    const base = rng.int(35, 80);
    if (rng.chance(0.55)) { // Reasonable win rate
      totalCredits += Math.floor(base * mult);
    }
  }
  // Compare to hacking income (~50c/hr × 2h = 100c active)
  return {
    maxDailyCredits: totalCredits,
    normalIncomeComparison: totalCredits / 100,
  };
}

// -- Scenario 5: Energy Waste Check --
function checkEnergyWaste(): string[] {
  const issues: string[] = [];
  // All resource-granting actions should cost energy:
  // - Hacking: costs energy ✓
  // - PvP: costs energy ✓
  // - Scan: costs energy ✓
  // - Module purchase: costs data/credits (no energy) - intentional, costs resources
  // - Passive income: no energy cost - intentional, capped at 24h
  // - Decisions: no energy cost - triggered by other actions that cost energy
  // - Data Vault: costs credits/data, no energy - intentional
  // All resource grants are gated by energy-costing actions or resource costs.
  // Passive income is time-gated.
  return issues;
}

function main() {
  const opts = parseCliOptions(process.argv.slice(2));
  console.log("=== Exploit Detection Simulation ===");
  console.log(`runs=${opts.runs} seed=${opts.seed}`);

  const guardrails: Array<{ name: string; pass: boolean; detail: string }> = [];

  // -- AFK Farming --
  console.log("\n[AFK Farming - Passive Only]");
  const afkResults: AfkResult[] = [];
  for (let i = 0; i < opts.runs; i++) {
    afkResults.push(runAfkFarming(opts.seed + i, 14));
  }
  const avgAfkNet = average(afkResults.map((r) => r.netPerDay));
  const sustainableRate = afkResults.filter((r) => r.sustainable).length / opts.runs;
  console.log(`Net credits/day (passive - repairs): ${avgAfkNet.toFixed(1)}`);
  console.log(`Sustainable rate: ${(sustainableRate * 100).toFixed(1)}%`);
  console.log(`Passive income: ${PASSIVE_CREDITS_PER_HOUR * 24}c/day`);
  console.log(`Avg repair cost: ${average(afkResults.map((r) => r.repairCostPerDay)).toFixed(0)}c/day`);

  guardrails.push({
    name: "Passive-only should NOT sustain a character",
    pass: sustainableRate < 0.5,
    detail: `sustainable in ${(sustainableRate * 100).toFixed(0)}% of runs (need <50%)`,
  });

  // -- Decision Reset --
  console.log("\n[Decision Reset via Death]");
  const resetResult = runDecisionReset();
  console.log(`Total re-seeable decision value: ${resetResult.totalReseableValue.toFixed(0)} credit-equiv`);

  if (resetResult.totalReseableValue > 500) {
    console.log("[sim:exploits] WARN: Decision reset value > 500 credits");
  }

  // -- PvP Target Sniping --
  console.log("\n[PvP Target Sniping - Max Daily Damage]");
  const snipeResults: PvpSnipeResult[] = [];
  for (let i = 0; i < opts.runs; i++) {
    snipeResults.push(runPvpSniping(opts.seed + i + 10000));
  }
  const avgMaxDmg = average(snipeResults.map((r) => r.maxDailyDamage));
  const capSufficient = snipeResults.filter((r) => r.isCapSufficient).length / opts.runs;
  console.log(`Avg max daily damage from ${PVP_MAX_ATTACKS_RECEIVED} attacks: ${avgMaxDmg.toFixed(0)} HP`);
  console.log(`Damage cap sufficient (< 20% total HP): ${(capSufficient * 100).toFixed(0)}%`);

  // -- Bot Farming Ceiling --
  console.log("\n[Bot Farming Ceiling]");
  const botResults: BotFarmResult[] = [];
  for (let i = 0; i < opts.runs; i++) {
    botResults.push(runBotFarming(opts.seed + i + 20000));
  }
  const avgBotCredits = average(botResults.map((r) => r.maxDailyCredits));
  const avgBotRatio = average(botResults.map((r) => r.normalIncomeComparison));
  console.log(`Max daily bot credits: ${avgBotCredits.toFixed(0)}`);
  console.log(`Bot/hacking ratio: ${(avgBotRatio * 100).toFixed(0)}%`);

  // -- Energy Waste Check --
  console.log("\n[Energy Waste Check]");
  const issues = checkEnergyWaste();
  if (issues.length === 0) {
    console.log("No energy-free resource exploits detected.");
  } else {
    for (const issue of issues) console.log(`  ISSUE: ${issue}`);
  }

  // -- Aggregate exploit check --
  // Active income estimate: ~50c/hr × 2h + 120 passive = ~220c/day
  const normalDailyIncome = 220;
  const maxExploitIncome = Math.max(avgAfkNet, avgBotCredits);

  guardrails.push({
    name: "No exploit yields >2x normal income",
    pass: maxExploitIncome <= normalDailyIncome * 2,
    detail: `max exploit: ${maxExploitIncome.toFixed(0)}c vs normal: ${normalDailyIncome}c`,
  });

  guardrails.push({
    name: "Decision reset value",
    pass: resetResult.totalReseableValue <= 500,
    detail: `${resetResult.totalReseableValue.toFixed(0)} (WARN if >500)`,
  });

  const allPass = printGuardrails("sim:exploits", guardrails);
  if (!allPass) process.exit(1);
}

main();
